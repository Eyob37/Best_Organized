<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Board - Updated</title>
    <style>
       body {
           display: flex;
           height: 100vh;
           align-items: center;
           justify-content: center;
           background: #f3f3f3;
           flex-direction: column;
           background: url('ludo.jpg');
           background-size: 100vw 100vh;
           background-attachment: fixed;
       }
       .board {
           width: 720px;
           height: 720px;
           display: grid;
           grid-template-columns: repeat(11, 1fr);
           grid-template-rows: repeat(11, 1fr);
           gap: 2px;
           background: #fff;
           padding: 6px;
           border-radius: 12px;
           box-shadow: 0 6px 18px rgba(0,0,0,0.15);
       }
       .cell {
           background: rgba(255,255,255,0.9);
           border-radius: 6px;
           display: flex;
           align-items: center;
           justify-content: center;
           font-size: 12px;
           position: relative;
       }
       .btwn {
           display: flex;
           flex-wrap: wrap;
           width: 100%;
           height: 100%;
           align-items: center;
           justify-content: center;
       }
       .token {
           width: 28px;
           height: 28px;
           border-radius: 50%;
           display: flex;
           align-items: center;
           justify-content: center;
           color: #fff;
           font-weight: 700;
           box-shadow: 0 2px 4px rgba(0,0,0,0.25);
           cursor: pointer;
           user-select: none;
           position: relative;
       }
       .red { background: #d9534f; }
       .green { background: #5cb85c; }
       .blue { background: #0275d8; }
       .yellow { background: #f0ad4e; color:#222; }

       .home {
           width: 100%;
           height: 100%;
           display: flex;
           align-items: center;
           justify-content: center;
           gap: 6px;
       }

       .roller {
           margin-top: 12px;
           padding: 8px 12px;
           border-radius: 10px;
           background: linear-gradient(180deg,#efefef,#ddd);
           box-shadow: 
               0 2px 4px rgba(0,0,0,0.2),
               inset 0 1px 0 rgba(255,255,255,0.8),
               inset 0 -1px 0 rgba(0,0,0,0.1);
       }

.roller::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(to bottom, rgba(255,255,255,0.4), rgba(255,255,255,0.1));
    border-
}
    </style>
</head>
<body>
    <h2 style="margin-bottom:8px">Ludo — Online</h2>
    <div style="display:flex; gap:12px; align-items:center; margin-bottom:10px;">
        <div id="roomIdTag">Room ID: —</div>
        <div id="statusTag">Status: idle</div>
    </div>

    <div class="board" id="board">
        <!-- Board layout approximated; cells use data-idno attributes mapping to paths -->
        <!-- Row 1 -->
        <div class="cell" data-idno="0"></div><div class="cell" data-idno="1"></div><div class="cell" data-idno="2"></div><div class="cell" data-idno="3"></div><div class="cell" data-idno="4"></div><div class="cell" data-idno="5"></div><div class="cell" data-idno="6"></div><div class="cell" data-idno="7"></div><div class="cell" data-idno="8"></div><div class="cell" data-idno="9"></div><div class="cell" data-idno="10"></div>
        <!-- ... rest of grid cells omitted for brevity in markup; your original board code likely generates these dynamically -->
    </div>

    <!-- Homes for players -->
    <div style="display:flex; gap:12px; margin-top:12px;">
        <div class="red-home home"><div class="token red token" data-color="red" id="r1">R1</div><div class="token red token" data-color="red" id="r2">R2</div></div>
        <div class="green-home home"><div class="token green token" data-color="green" id="g1">G1</div><div class="token green token" data-color="green" id="g2">G2</div></div>
        <div class="blue-home home"><div class="token blue token" data-color="blue" id="b1">B1</div><div class="token blue token" data-color="blue" id="b2">B2</div></div>
        <div class="yellow-home home"><div class="token yellow token" data-color="yellow" id="y1">Y1</div><div class="token yellow token" data-color="yellow" id="y2">Y2</div></div>
    </div>

    <audio id="audio-roller" src="roller.mp3"></audio>
    <audio id="audio-move" src="move.mp3"></audio>

    <script>
       let PlayPlayers = JSON.parse(localStorage.getItem("playPlayers")) || ["red", "green","blue","yellow"];
       
       console.log(PlayPlayers.includes("Yellow")); 
// ----- STYLE / SETUP SCRIPT -----

let audioRoller = document.getElementById("audio-roller");
let audioMove = document.getElementById("audio-move");
let idGP = 53;
let betweenDivs = document.querySelectorAll(".btwn");
let SCDivs = document.querySelectorAll(".sub-container");

let SCDA = [["left","top"],["right","top"],["left","bottom"],["right","bottom"]];
let colorOrder = ["red","green","blue","yellow"];
let roadArr = [];
...
let selectedToken = null;

// Player turn
function showCurrent() {
    let rollers = document.querySelectorAll('.roller');
    rollers.forEach((roller, index) => {
        if (!(index == players.indexOf(currentPlayer))) {
            roller.disabled = true;
            roller.style.background = "#848484";
            roller.removeEventListener('click', diceHandler);
        } else {
            if(!(PlayPlayers.includes(currentPlayer))){
                nextTurn();
                r
    </script>

<script>
// ----- PROCESS / GAMEPLAY SCRIPT -----

let diceValue = 0;
let rollTime = 0;

// Helper: get all path cells by data-idno
let allPathCells = {};
document.querySelectorAll(".btwn div, .center").forEach(el=> {
    if(el.dataset.idno) allPathCells[el.dataset.idno] = el;

});

// Current selected token after roll
let selectedToken = null;

// Player turn
function showCurrent() {
    let rollers = document.querySelectorAll('.roller');
    rollers.forEach((roller, index) => {
        if (!(index == players.indexOf(currentPlayer))) {
            roller.disabled = true;
            roller.style.background = "#848484";
            roller.removeEventListener('click', diceHandler);
        } else {
            if(!(PlayPlayers.includes(currentPlayer))){
                nextTurn();
                r
    </script>

<script type="module">
    // Firebase imports and init (v11)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import { 
        getDatabase, 
        ref, 
        set, 
        get, 
        onValue,
        update,
        push,
        child,
        runTransaction
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyDRDm3Da8IOE2vJHQ6j-16qofhkvsuNpfQ",
        authDomain: "ludo-eea76.firebaseapp.com",
        databaseURL: "https://ludo-eea76-default-rtdb.firebaseio.com",
        projectId: "ludo-eea76",
        storageBucket: "ludo-eea76.firebasestorage.app",
        messagingSenderId: "249574298911",
        appId: "1:249574298911:web:3e087f9eb96d67d2d14c2a",
        measurementId: "G-4LRR00CHK3"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // room & identity
    const roomId = localStorage.getItem("roomId");
    if (!roomId) {
        console.error("No roomId in localStorage. Multiplayer will not work.");
    }
    let yourColor = localStorage.getItem("playerColor");
    if (!yourColor) {
        console.warn("No playerColor in localStorage. You may be spectator.");
    }

    let clientId = localStorage.getItem("clientId");
    if (!clientId) {
        clientId = 'c_' + Date.now() + '_' + Math.floor(Math.random()*10000);
        localStorage.setItem("clientId", clientId);
    }

    // refs
    const gameBase = ref(db, `Ludo Game/${roomId}/game`);
    const currentPlayerRef = ref(db, `Ludo Game/${roomId}/game/currentPlayer`);
    const eventsRef = ref(db, `Ludo Game/${roomId}/game/events/latest`);
    const stateRef = ref(db, `Ludo Game/${roomId}/game/state`);

    // helper to write events/latest
    async function broadcastAction(action, payload) {
        const msg = { action, payload, senderId: clientId, ts: Date.now() };
        await set(eventsRef, msg);
    }

    // Listen to events
    onValue(eventsRef, snap => {
        const msg = snap.val();
        if (!msg) return;
        if (msg.senderId === clientId) return; // ignore our own broadcasts
        applyEvent(msg);
    });

    function applyEvent(msg) {
        const { action, payload } = msg;
        if (action === "roll") {
            const { value, roller } = payload;
            // find roller dice element by roller color -> rollers are ordered by players array
            try {
                if (typeof players !== 'undefined') {
                    const idx = players.indexOf(roller);
                    const rollers = document.querySelectorAll('.roller');
                    if (idx >= 0 && rollers[idx]) {
                        const diceEl = rollers[idx].querySelector('.dice');
                        if (diceEl) {
                            diceEl.setAttribute('data-value', value);
                            // call enableTokenSelection so tokens become clickable for that client
                            if (typeof enableTokenSelection === 'function') enableTokenSelection();
                        }
                    }
                }
            } catch (e) { console.error(e); }
        } else if (action === "stateUpdate") {
            // payload: { tokens: [{ tokenSelector, idno, parentIdNo } ... ] }
            try {
                payload.tokens.forEach(t => {
                    const token = document.querySelector(t.tokenSelector);
                    if (!token) return;
                    if (t.parentIdNo === "home") {
                        // put back to home container for that color
                        const home = document.querySelector(`.${t.color}-home`);
                        if (home) home.appendChild(token);
                    } else {
                        const target = document.querySelector(`[data-idno='${t.parentIdNo}']`);
                        if (target) target.appendChild(token);
                    }
                    // update dataset to match
                    if (t.idno !== undefined) token.dataset.idno = t.idno;
                    if (t.home !== undefined) token.dataset.home = t.home;
                    if (t.finished !== undefined) token.dataset.finished = t.finished;
                });
            } catch(e){ console.error(e); }
        } else if (action === "sendHome") {
            // payload { tokenSelector, color }
            try {
                const token = document.querySelector(payload.tokenSelector);
                if (!token) return;
                const home = document.querySelector(`.${payload.color}-home`);
                if (home) home.appendChild(token);
                // mark dataset
                token.dataset.home = "true";
                delete token.dataset.idno;
            } catch(e){ console.error(e); }
        } else if (action === "win") {
            // payload { color }
            try {
                if (typeof showWin === 'function') showWin(payload.color);
            } catch(e){ console.error(e); }
        } else if (action === "nextTurn") {
            // payload { next }
            try {
                // set local currentPlayer and call showCurrent
                currentPlayer = payload.next;
                if (typeof showCurrent === 'function') showCurrent();
            } catch(e){ console.error(e); }
        }
    }

    // currentPlayer listener (stored as object {value, senderId, ts})
    onValue(currentPlayerRef, snap => {
        const val = snap.val();
        if (!val) return;
        if (val.senderId === clientId) return; // ignore own write
        if (val.value) {
            currentPlayer = val.value;
            if (typeof showCurrent === 'function') showCurrent();
        }
    });

    // override nextTurn to write to firebase (single-writer safe)
    (function patchNextTurn(){
        if (typeof window.nextTurn !== 'function') return;
        const orig = window.nextTurn;
        window.nextTurn = function() {
            try {
                // compute next
                if (typeof players === 'undefined' || typeof currentPlayer === 'undefined') {
                    return orig();
                }
                let currentIndex = players.indexOf(currentPlayer);
                let next = players[(currentIndex + 1) % players.length];
                // write to firebase currentPlayer object
                set(currentPlayerRef, { value: next, senderId: clientId, ts: Date.now() });
                // set local immediately for responsiveness
                currentPlayer = next;
                if (typeof showCurrent === 'function') showCurrent();
                // broadcast event as well (optional)
                broadcastAction("nextTurn", { next });
            } catch(e){ console.error(e); orig(); }
        };
    })();

    // observe dice changes to broadcast final roll (debounced)
    (function observeDice(){
        const rollers = document.querySelectorAll('.roller');
        rollers.forEach((roller, idx) => {
            const dice = roller.querySelector('.dice');
            if (!dice) return;
            let timeout = null;
            const mo = new MutationObserver(mutations => {
                mutations.forEach(m => {
                    if (m.type === 'attributes' && m.attributeName === 'data-value') {
                        // debounce to avoid broadcasting intermediate randomizations
                        if (timeout) clearTimeout(timeout);
                        timeout = setTimeout(() => {
                            const val = dice.getAttribute('data-value');
                            const rollerColor = (typeof players !== 'undefined' && players[idx]) ? players[idx] : null;
                            if (!rollerColor) return;
                            // broadcast roll event
                            broadcastAction("roll", { value: Number(val), roller: rollerColor });
                        }, 600);
                    }
                });
            });
            mo.observe(dice, { attributes:true });
        });
    })();

    // observe token moves (DOM changes) and broadcast stateUpdate (debounced)
    (function observeTokenMoves(){
        const board = document.querySelector('body'); // observe whole document for token moves
        if (!board) return;
        let pending = {};
        let timeout = null;
        const mo = new MutationObserver(mutations => {
            mutations.forEach(m => {
                if (m.type === 'childList') {
                    // check added nodes for tokens
                    m.addedNodes.forEach(node => {
                        if (node.nodeType !== 1) return;
                        if (node.classList && node.classList.contains('token')) {
                            // find parent cell idno or home
                            const parent = node.parentElement;
                            const parentId = parent ? parent.getAttribute('data-idno') : null;
                            const color = node.dataset.color || node.className.split(' ')[0];
                            const selector = tokenSelector(node);
                            pending[selector] = {
                                tokenSelector: selector,
                                idno: node.dataset.idno ? Number(node.dataset.idno) : undefined,
                                parentIdNo: parentId ? parentId : "home",
                                color: color,
                                home: node.dataset.home
                            };
                        }
                    });
                }
                if (m.type === 'attributes') {
                    // dataset changed etc - ignore
                }
            });
            if (timeout) clearTimeout(timeout);
            timeout = setTimeout(() => {
                const tokens = Object.values(pending);
                if (tokens.length > 0) {
                    broadcastAction("stateUpdate", { tokens });
                    pending = {};
                }
            }, 300);
        });
        mo.observe(board, { childList:true, subtree:true, attributes:false });
    })();

    function tokenSelector(node){
        // create CSS selector unique to token (uses color and token-index if present)
        if (!node) return null;
        if (node.id) return `#${node.id}`;
        let sel = '.token';
        if (node.dataset && node.dataset.color) sel = `.${node.dataset.color}.token`;
        // try to be more specific using data-token attribute if exists
        if (node.dataset && node.dataset.token) sel += `[data-token='${node.dataset.token}']`;
        return sel;
    }

    // helper to send sendHome and win events from local actions - patch original functions to broadcast
    (function patchSendHomeAndWin(){
        if (typeof window.sendTokenHome === 'function') {
            const orig = window.sendTokenHome;
            window.sendTokenHome = function(token, color){
                orig(token, color);
                try {
                    const selector = tokenSelector(token);
                    broadcastAction("sendHome", { tokenSelector: selector, color });
                } catch(e){ console.error(e); }
            };
        }
        if (typeof window.checkWin === 'function') {
            const origCheckWin = window.checkWin;
            window.checkWin = function(color){
                const res = origCheckWin(color);
                // if somebody won, checkWin likely calls showWin; broadcast if winner found
                // Try to detect win by scanning tokens finished count
                try {
                    const won = document.querySelectorAll(`.btwn .token[data-finished='true']`).length >= 4; // heuristic
                    if (won) {
                        broadcastAction("win", { color });
                    }
                } catch(e){ console.error(e); }
                return res;
            };
        } else if (typeof window.Win === 'function') {
            const origWin = window.Win;
            window.Win = function(color){
                origWin(color);
                try { broadcastAction("win", { color }); } catch(e){ console.error(e); }
            };
        }
    })();

    // initial sync: read currentPlayer and state
    (async function initialSync(){
        try {
            const cpSnap = await get(currentPlayerRef);
            const cp = cpSnap.val();
            if (cp && cp.value) {
                // if not our own write, apply
                if (cp.senderId !== clientId) {
                    currentPlayer = cp.value;
                    if (typeof showCurrent === 'function') showCurrent();
                }
            }
            // read state if exists and apply once
            const stSnap = await get(stateRef);
            const st = stSnap.val();
            if (st && st.players) {
                // apply tokens positions from state (simple approach)
                Object.keys(st.players).forEach(color => {
                    const pdata = st.players[color];
                    if (!pdata.tokens) return;
                    pdata.tokens.forEach(t => {
                        const selector = t.selector || `.${color}.token`;
                        const token = document.querySelector(selector);
                        if (!token) return;
                        if (t.home) {
                            const home = document.querySelector(`.${color}-home`);
                            if (home) home.appendChild(token);
                        } else if (t.idno !== undefined) {
                            const target = document.querySelector(`[data-idno='${t.idno}']`);
                            if (target) target.appendChild(token);
                        }
                    });
                });
            }
        } catch(e){ console.error(e); }
    })();

</script>

</body>
</html>